#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
RRD Viewer with Briefing - Modern UI Version

이 스크립트는 rerun 뷰어로 RRD 파일을 열고 3D 장면 레이아웃과 관련된
브리핑 정보를 보여주는 현대적인 UI 팝업 창을 표시합니다.

Usage:
    python qt_rerun_briefing.py -i scene0002_00.rrd [options]
"""

import os
import sys
import locale
import argparse
import tempfile
import subprocess
import threading
import time
import shutil
import platform
import json
import markdown
from pathlib import Path
import requests
import configparser
from datetime import datetime
import random
import codecs
import torch
from transformers import AutoTokenizer, AutoModelForCausalLM
from spatiallm.layout.layout import Layout
import webbrowser

try:
    from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                                 QHBoxLayout, QLabel, QTextEdit, QPushButton, 
                                 QSplitter, QFrame, QMessageBox, QComboBox,
                                 QProgressBar, QToolBar, QAction, QFileDialog,
                                 QSizePolicy, QSpacerItem, QGraphicsDropShadowEffect,
                                 QStatusBar, QDialog, QLineEdit, QFormLayout)
    from PyQt5.QtGui import QFont, QIcon, QTextCursor, QColor, QPalette, QFontDatabase, QPixmap, QTextDocument, QPainter, QBrush, QPen
    from PyQt5.QtCore import Qt, QThread, pyqtSignal, QUrl, QSize, QTimer
except ImportError:
    print("PyQt5 라이브러리가 필요합니다. 다음 명령으로 설치하세요:")
    print("pip install PyQt5")
    sys.exit(1)

try:
    import markdown
except ImportError:
    print("Python-Markdown 라이브러리가 필요합니다. 다음 명령으로 설치하세요:")
    print("pip install markdown")
    sys.exit(1)

# 시스템 기본 인코딩 확인 및 설정
print(f"Current locale: {locale.getdefaultlocale()}")
print(f"Current file system encoding: {sys.getfilesystemencoding()}")
print(f"Current default encoding: {sys.getdefaultencoding()}")

# 환경 변수 설정 (한글 처리)
os.environ["PYTHONIOENCODING"] = "utf-8"
os.environ["LANG"] = "ko_KR.UTF-8"

# layout_based_briefing.py에서 필요한 함수들 통합
def load_layout_from_file(layout_file):
    """
    Load a layout from a file generated by inference.py
    
    Args:
        layout_file (str): Path to the layout file
        
    Returns:
        layout (Layout): The layout object
    """
    try:
        with open(layout_file, 'r', encoding='utf-8') as f:
            layout_str = f.read()
        
        # Create Layout object from the layout string
        layout = Layout(layout_str)
        return layout
    except Exception as e:
        print(f"Error loading layout from file: {str(e)}")
        raise

def analyze_layout(layout):
    """
    Analyze a layout to extract key information
    
    Args:
        layout (Layout): The layout object
        
    Returns:
        dict: Dictionary containing analysis results
    """
    # Get layout string
    layout_str = layout.to_language_string()
    layout_lines = layout_str.strip().split('\n')
    
    # Categorize entities by parsing the layout string
    walls = []
    doors = []
    windows = []
    objects = []
    
    for line in layout_lines:
        if line.startswith('wall_') or 'Wall(' in line:
            walls.append(line)
        elif line.startswith('door_') or 'Door(' in line:
            doors.append(line)
        elif line.startswith('window_') or 'Window(' in line:
            windows.append(line)
        elif line.startswith('bbox_') or 'Bbox(' in line:
            objects.append(line)
    
    # Count object types
    object_types = {}
    for obj in objects:
        try:
            if "=" in obj and "(" in obj:
                # Format like: bbox_0=Bbox(sofa,-3.5064208984375,0.9839955329895016,...)
                obj_type = obj.split('(')[1].split(',')[0]
            else:
                # Other format
                parts = obj.split(',')
                obj_type = parts[0]
                
            if obj_type in object_types:
                object_types[obj_type] += 1
            else:
                object_types[obj_type] = 1
        except Exception as e:
            print(f"Failed to parse object: {obj}, error: {e}")
            continue
    
    # Calculate approximate room dimensions
    x_coords = []
    y_coords = []
    heights = []
    
    for wall in walls:
        try:
            # Try to extract coordinates based on the format
            if "Wall(" in wall:
                # Format: wall_0=Wall(-3.15,-4.01,0.02,-0.95,-4.01,0.02,2.72,0.0)
                coords = wall.split('(')[1].split(')')[0].split(',')
                x_coords.extend([float(coords[0]), float(coords[3])])
                y_coords.extend([float(coords[1]), float(coords[4])])
                if len(coords) > 6:
                    heights.append(float(coords[6]))
        except Exception as e:
            print(f"Failed to parse wall coordinates: {wall}, error: {e}")
            continue
    
    # Calculate dimensions if we have coordinates
    if x_coords and y_coords:
        width = max(x_coords) - min(x_coords)
        length = max(y_coords) - min(y_coords)
        height = max(heights) if heights else 2.4  # Default height if not available
        area = width * length
        volume = area * height
    else:
        width = length = height = area = volume = 0
    
    # Infer room type
    room_type = "Unknown"
    if object_types:
        if any(obj_type in ['bed', 'pillow', 'nightstand'] for obj_type in object_types):
            room_type = "Bedroom"
        elif any(obj_type in ['sofa', 'tv', 'coffee_table', 'couch'] for obj_type in object_types):
            room_type = "Living Room"
        elif any(obj_type in ['dining_table', 'chair', 'dining_table_combination'] for obj_type in object_types):
            room_type = "Dining Room"
        elif any(obj_type in ['toilet', 'sink', 'bathtub', 'shower'] for obj_type in object_types):
            room_type = "Bathroom"
        elif any(obj_type in ['stove', 'refrigerator', 'oven', 'microwave'] for obj_type in object_types):
            room_type = "Kitchen"
    
    return {
        "wall_count": len(walls),
        "door_count": len(doors),
        "window_count": len(windows),
        "object_count": len(objects),
        "object_types": object_types,
        "width": width,
        "length": length,
        "height": height,
        "area": area,
        "volume": volume,
        "room_type": room_type
    }

class RerunViewerThread(QThread):
    """
    Rerun 뷰어를 실행하기 위한 백그라운드 스레드
    """
    error_signal = pyqtSignal(str)

    def __init__(self, rrd_file):
        QThread.__init__(self)
        self.rrd_file = rrd_file

    def run(self):
        try:
            # Rerun 뷰어 실행
            subprocess.Popen(["rerun", self.rrd_file])
        except Exception as e:
            self.error_signal.emit(f"Rerun 뷰어 실행 오류: {str(e)}")

class CodeExecutionThread(QThread):
    """
    생성된 Python 코드를 실행하는 백그라운드 스레드
    """
    execution_completed = pyqtSignal(bool, str, str)  # 성공 여부, 결과 메시지, 결과 파일 경로
    
    def __init__(self, code, tmp_dir=None):
        QThread.__init__(self)
        self.code = code
        self.tmp_dir = tmp_dir or tempfile.mkdtemp(prefix="spatialLM_code_")
        self.code_file = os.path.join(self.tmp_dir, "generated_code.py")
        
    def run(self):
        try:
            # 코드를 임시 파일에 저장
            with open(self.code_file, 'w', encoding='utf-8') as f:
                f.write(self.code)
            
            # 간단하게 python 명령어만 사용
            if platform.system() == "Windows":
                cmd = f"python {self.code_file}"
            else:
                cmd = f"python {self.code_file}"
            
            # 실행
            process = subprocess.Popen(
                cmd, 
                shell=True, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE,
                cwd=self.tmp_dir
            )
            
            # 출력 캡처
            stdout, stderr = process.communicate(timeout=60)  # 60초 타임아웃
            
            # 결과 확인
            if process.returncode == 0:
                # 성공적으로 실행됨 - 생성된 파일 찾기
                result_files = []
                for file in os.listdir(self.tmp_dir):
                    if file != "generated_code.py" and file.endswith(('.png', '.jpg', '.jpeg', '.html', '.svg', '.pdf')):
                        result_files.append(os.path.join(self.tmp_dir, file))
                
                if result_files:
                    # 결과 파일이 생성됨
                    result_file = result_files[0]  # 첫 번째 파일 사용
                    success_msg = f"코드가 성공적으로 실행되었습니다. 결과 파일: {os.path.basename(result_file)}"
                    self.execution_completed.emit(True, success_msg, result_file)
                else:
                    # 결과 파일이 없음
                    stdout_text = stdout.decode('utf-8', errors='replace')
                    self.execution_completed.emit(True, f"코드는 실행되었지만 결과 파일을 찾을 수 없습니다. 출력:\n{stdout_text}", "")
            else:
                # 실행 오류
                stderr_text = stderr.decode('utf-8', errors='replace')
                self.execution_completed.emit(False, f"코드 실행 중 오류가 발생했습니다:\n{stderr_text}", "")
        
        except Exception as e:
            self.execution_completed.emit(False, f"코드 실행 프로세스 오류: {str(e)}", "")

class QAThread(QThread):
    """
    질문-답변 생성을 위한 백그라운드 스레드 (ChatGPT API 사용)
    """
    answer_signal = pyqtSignal(str)
    error_signal = pyqtSignal(str)
    stream_signal = pyqtSignal(str)  # 스트리밍 출력을 위한 시그널 추가
    code_generated_signal = pyqtSignal(str)  # 코드 생성 시그널 추가
    
    def __init__(self, layout_file, briefing_content, question, api_key, model="gpt-4", language="korean"):
        QThread.__init__(self)
        self.layout_file = layout_file
        self.briefing_content = briefing_content
        self.question = question
        self.api_key = api_key
        self.model = model
        self.language = language
        
    def run(self):
        """
        QA 스레드 실행 - 레이아웃 및 브리핑 내용을 바탕으로 질문-답변 생성
        
        특별 키워드 "IIFA" 사용법:
        - 메시지 시작 또는 끝에 "IIFA"를 추가하면 시각화/코드 생성 모드 활성화
        - 그 외의 경우에는 일반 전술 조언 모드로 작동
        - 키워드는 대소문자를 구분하지 않음 (iifa, IIFA 모두 인식)
        """
        try:
            # 레이아웃 정보 로드
            with open(self.layout_file, 'r', encoding='utf-8') as f:
                layout_str = f.read()
            
            # API 요청 헤더 및 URL 설정
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.api_key}"
            }
            api_url = "https://api.openai.com/v1/chat/completions"
            
            # 언어 설정
            lang_instruction = ""
            if self.language == "korean":
                lang_instruction = "당신의 응답은 반드시 한국어로 작성해야 합니다. 모든 용어와 설명은 한국어로 번역하여 제공하세요."
            
            # 간단한 IIFA 키워드 기반 시각화 요청 확인
            # 질문의 시작 또는 끝에 "IIFA"가 있는지 확인
            question_lower = self.question.lower().strip()
            is_code_request = question_lower.startswith("iifa") or question_lower.endswith("iifa")
            
            # IIFA 키워드가 있는 경우, 질문에서 키워드 제거
            if is_code_request:
                if question_lower.startswith("iifa"):
                    # "iifa" 뒤에 공백이 있을 경우 처리
                    self.question = self.question.lstrip().lower().replace("iifa", "", 1).lstrip()
                elif question_lower.endswith("iifa"):
                    # "iifa" 앞에 공백이 있을 경우 처리
                    self.question = self.question.rstrip().lower().rstrip("iifa").rstrip()
            
            system_prompt = ""
            user_prompt = ""
            
            if is_code_request:
                # --- 코드 생성 요청 프롬프트 ---
                system_prompt = """당신은 Python 코드 생성 및 데이터 시각화 전문가입니다. 사용자의 요청과 제공된 컨텍스트(레이아웃, 브리핑 등)를 바탕으로 지도, 차트, 그림 등을 생성하는 Python 코드를 작성하세요.

**중요 요구사항:**
1. 사용자가 명시적으로 요청한 모든 요소와 기능을 빠짐없이 구현하세요.
2. 시각화에는 적절한 제목, 레이블, 범례 등 필수 요소를 반드시 포함하세요.
3. 시각적 명확성을 위해 적절한 색상, 크기, 폰트 크기를 사용하세요.
4. 모든 레이블, 타이틀, 주석은 반드시 영어로 작성하세요. 한국어를 사용하지 마세요.

**출력 형식:**
1. 출력 시작 부분에 필요한 라이브러리 설치 안내를 포함하세요 (예: `pip install matplotlib folium pandas`).
2. 생성된 Python 코드를 마크다운 코드 블록 안에 넣으세요 (```python ... ```).
3. 코드는 반드시 현재 디렉토리에 결과 이미지 파일(PNG, JPG, HTML 등)을 저장하도록 작성하고, 파일명을 명확히 지정하세요.
4. 라이브러리 임포트와 필요한 모든 기능이 포함된 완전한 실행 가능 코드를 제공하세요.
5. 파일 저장 경로는 상대 경로로 지정하여 현재 작업 디렉토리에 저장되게 하세요.
6. 코드를 너무 복잡하게 만들지 말고, 사용자 요청을 정확히 수행하는 간결한 코드를 작성하세요.
7. 모든 코드에 주석을 달아 각 부분의 역할을 명확히 설명하세요."""

                # 필요한 컨텍스트 정보를 사용자 프롬프트에 포함
                user_prompt = f"""다음 컨텍스트 정보를 참고하여 요청을 처리하세요:

[레이아웃 정보]
{layout_str}... (생략)

[브리핑 내용 요약]
{self.briefing_content}... (생략)

[사용자 요청]
{self.question}

**프로그래밍 요구사항:**
1. 필요한 모든 라이브러리를 import 하는 코드를 포함하세요.
2. 완전하고 실행 가능한 Python 코드를 제공하세요.
3. 결과 파일(지도, 차트, 그림 등)은 명확한 파일명으로 현재 디렉토리에 저장하세요.
4. 마크다운 코드 블록(```python ... ```) 안에 코드를 넣어주세요.
5. 사용자가 요청한 모든 요소(색상, 스타일, 데이터 항목 등)를 정확히 구현하세요.
6. 데이터가 시각적으로 명확하게 보이도록 그래프 크기, 폰트 크기, 색상 등을 적절히 조정하세요.
7. 모든 레이블, 제목, 주석은 영어로 작성하세요. 한국어를 사용하지 마세요.
8. 데이터 시각화에 필요한 적절한 라이브러리를 선택하세요:
   - 일반 그래프/차트: matplotlib, seaborn
   - 인터랙티브 차트: plotly
   - 지도: folium, geopandas
   - 3D 시각화: matplotlib(3D), plotly
   - 네트워크 그래프: networkx
9. 오류 처리 코드를 포함하여 예외 상황에 대응하세요.
10. 코드 실행 전 필요한 라이브러리 설치 명령어를 코드 외부에 명시하세요.
11. 사용자가 2D 레이아웃을 요청한 경우 벽, 창문, 문에 대한 정보를 포함하고 창문과 문은 벽의 모양과 방향에 맞춰 정렬하세요."""
            else:
                # --- 기존 Q&A 프롬프트 ---
                system_prompt = f"""당신은 고급 군사 작전 참모 및 지휘 결심 보좌 전문가입니다. 제공된 3D 공간 레이아웃 정보와 이미 생성된 전술적 브리핑을 바탕으로 지휘관에게 작전 지휘결심을 위한 정확한 조언과 분석을 제공합니다.

지휘관과의 상호작용에서 다음 역할을 수행하세요:
1. 의사결정 촉진자: 지휘관이 신속하고 효과적인 결정을 내릴 수 있도록 필요한 정보를 명확하게 제공
2. 분석가: 데이터 기반 정보를 해석하여 지휘관이 상황을 완전히 이해할 수 있도록 지원
3. 위험 평가자: 다양한 행동 방침의 위험과 기회를 정량적으로 평가하여 제시
4. 옵션 제시자: 여러개의 실행 가능한 대안을 우선순위와 함께 제시

답변 형식:
- 정보 전달 시 마크다운은 필요한 경우에만 적절히 활용하세요.
- 핵심 정보와 주요 구분이 필요한 경우 제목(##, ###)을 사용하세요.
- 주요 옵션이나 중요 항목은 목록으로 구분하세요.
- 중요한 경고나 위험은 강조하세요.
- 통계 데이터나 비교가 필요한 경우 표를 활용하세요.
- 자연스러운 문단 흐름을 유지하고, 모든 내용을 마크다운으로 강제하지 마세요.
- 아래의 원칙을 준수하되, 지나치게 양식에 구애받지 마세요. 질문과 답변 형태에 맞춰 적절한 형태로 답변하세요.

다음 원칙을 준수하세요:
- 구체적인 수치와 데이터에 기반한 객관적이고 명확한 답변 제공
- 가능한 한 정확한 수치, 좌표, 시간, 거리 등 구체적 데이터 포함
- 지휘관의 질문에 대해 간결하면서도 충분히 상세한 정보 제공
- 대안의 장단점과 위험 요소를 구체적인 근거와 함께 평가
- 실행 가능한 옵션을 우선순위에 따라 현실적 제약을 고려하여 제시
- 레이아웃 및 브리핑 정보로부터 추론한 근거를 명확히 제시
- 긴급 상황에서 신속한 결정을 위한 핵심 사항 강조
- 불확실한 정보는 그 불확실성의 정도와 함께 표시

**중요:** 질문의 내용과 의도를 정확히 파악하여 적절한 형태로 대응하세요. 시각화나 데이터 표현을 명시적으로 요청하지 않은 경우에는 자연스러운 대화형 답변을 제공하고, 코드를 생성하지 마세요."""

                # 사용자 프롬프트 생성
                user_prompt = f"""다음은 3D 공간의 상세 레이아웃 정보입니다:

{layout_str}

그리고 이 공간에 대해 생성된 전술적 브리핑 내용입니다:

{self.briefing_content}

위 정보를 토대로 다음 질문에 대해 답변해주세요:

{self.question}

다음 지침에 따라 응답해주세요:
1. 정보 구조화가 필요한 경우에만 적절히 마크다운을 활용하세요. 모든 내용을 마크다운으로 강제하지 말고, 자연스러운 흐름을 유지하세요.

2. 구체적인 근거와 상세 정보를 제공하세요:
   - 가능한 한 정확한 수치(거리, 시간, 각도, 좌표 등)를 포함하세요
   - 공간의 구체적인 특성과 그 전술적 의미를 설명하세요
   - 추론의 과정과 근거를 명확히 하세요
   - 제안하는 옵션의 실행 가능성에 대한 구체적 평가를 포함하세요

3. 옵션을 제시할 때는:
   - 각 옵션의 구체적인 실행 방법(누가, 어디서, 어떻게)을 포함하세요
   - 예상되는 결과와 잠재적 장애요소를 설명하세요
   - 필요한 자원과 시간을 명시하세요
   - 성공 확률에 대한 평가를 제공하세요

4. 응답을 통해 지휘관이 즉시 결정을 내릴 수 있을 정도로 명확하고 실행 가능한 조언을 제공하세요.

5. 질문의 성격에 따라 적절한 형식으로 답변하세요:
   - 일반적인 조언이나 정보를 요청하는 경우: 자연스러운 대화형 답변
   - 전술적 결정이 필요한 경우: 구조화된 옵션 제시
   - 분석을 요청하는 경우: 데이터 기반 분석 결과
   - 특별히 시각화를 요청하지 않는 한 코드를 생성하지 마세요.

레이아웃의 공간적 특성과 전술적 브리핑에서 제공된 정보를 활용하여 지휘관의 결심에 직접적으로 도움이 될 수 있는 구체적이고 실용적인 조언을 제시하십시오.{lang_instruction}"""
            
            # 메시지 구성
            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
            
            # API 요청 본문 구성 - 스트리밍 모드 활성화
            request_body = {
                "model": self.model,
                "messages": messages,
                "temperature": 0.25,
                "max_tokens": 10000,
                "top_p": 0.95,
                "frequency_penalty": 0,
                "presence_penalty": 0.1,  # 약간의 다양성 추가
                "stream": True  # 스트리밍 모드 활성화
            }
            
            # 전체 응답을 저장할 변수
            full_response = ""
            
            # API 요청 전송 (스트리밍)
            with requests.post(
                api_url,
                headers=headers,
                json=request_body,
                timeout=120,  # 타임아웃 120초
                stream=True  # 스트리밍 모드
            ) as response:
                
                if response.status_code == 200:
                    for line in response.iter_lines():
                        if line:
                            line_text = line.decode('utf-8')
                            
                            # "data: " 접두사 처리
                            if line_text.startswith("data: "):
                                line_text = line_text[6:]  # "data: " 제거
                            
                            # 스트리밍 종료 메시지 확인
                            if line_text == "[DONE]":
                                break
                                
                            try:
                                # JSON 파싱
                                json_data = json.loads(line_text)
                                
                                # 델타 텍스트 추출
                                if "choices" in json_data and json_data["choices"]:
                                    delta = json_data["choices"][0].get("delta", {})
                                    
                                    if "content" in delta:
                                        content = delta["content"]
                                        full_response += content
                                        # 실시간으로 업데이트 시그널 발생
                                        self.stream_signal.emit(content)
                            except json.JSONDecodeError:
                                # JSON 디코딩 오류는 무시
                                continue
                    
                    # 코드 생성 요청인 경우, 코드 부분 추출
                    if is_code_request:
                        # 마크다운 형식에서 Python 코드 블록 추출
                        import re
                        code_pattern = r'```python\s*(.*?)\s*```'
                        code_matches = re.findall(code_pattern, full_response, re.DOTALL)
                        
                        if code_matches:
                            # 코드 추출에 성공하면 시그널 발생
                            extracted_code = code_matches[0]
                            self.code_generated_signal.emit(extracted_code)
                    
                    # 스트리밍이 완료되면 최종 응답 전송
                    self.answer_signal.emit(full_response)
                else:
                    error_msg = f"API 오류 (코드 {response.status_code}): {response.text}"
                    self.error_signal.emit(error_msg)
        
        except Exception as e:
            self.error_signal.emit(f"질문 처리 오류: {str(e)}")

class ApiKeyDialog(QDialog):
    """
    API 키 설정 다이얼로그
    """
    def __init__(self, parent=None, current_key=""):
        super().__init__(parent)
        self.setWindowTitle("ChatGPT API 키 설정")
        self.resize(500, 180)
        
        layout = QVBoxLayout()
        
        # 설명 레이블
        info_label = QLabel("OpenAI API 키를 입력하세요. API 키는 로컬에 암호화되지 않은 상태로 저장됩니다. "
                           "한 번 입력하면 다음에 프로그램을 실행할 때 자동으로 로드됩니다.")
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # API 키 입력 폼
        form_layout = QFormLayout()
        self.api_key_input = QLineEdit()
        self.api_key_input.setText(current_key)
        self.api_key_input.setEchoMode(QLineEdit.Password)
        self.api_key_input.setMinimumWidth(350)
        form_layout.addRow("API 키:", self.api_key_input)
        
        # 모델 선택
        self.model_combo = QComboBox()
        self.model_combo.addItems(["gpt-4o-2024-11-20", "gpt-4o-mini-2024-07-18", "o1-2024-12-17"])
        # 기본 모델 선택 (gpt-4o)
        self.model_combo.setCurrentIndex(0)
        form_layout.addRow("모델:", self.model_combo)
        
        layout.addLayout(form_layout)
        
        # 버튼 영역
        button_layout = QHBoxLayout()
        self.save_button = QPushButton("저장")
        self.cancel_button = QPushButton("취소")
        
        self.save_button.clicked.connect(self.accept)
        self.save_button.setStyleSheet("""
            QPushButton {
                background-color: #2ecc71;
                color: white;
                border-radius: 4px;
                padding: 6px 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #27ae60;
            }
        """)
        
        self.cancel_button.clicked.connect(self.reject)
        
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.cancel_button)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
    
    def get_api_key(self):
        """API 키 반환"""
        return self.api_key_input.text()
    
    def get_model(self):
        """선택된 모델 반환"""
        return self.model_combo.currentText()

class BriefingViewer(QMainWindow):
    """
    브리핑 정보를 표시하는 메인 윈도우
    """
    def __init__(self, rrd_file, model_path="manycore-research/SpatialLM-Llama-1B", language="korean", layout_file=None, briefing_file=None):
        super().__init__()
        
        # RRD 파일 경로 설정
        self.rrd_file = rrd_file
        self.rrd_dir = os.path.dirname(self.rrd_file)
        self.basename = os.path.splitext(os.path.basename(self.rrd_file))[0]
        
        # SpatialLM 모델 경로 설정
        self.model_path = model_path
        
        # 언어 설정
        self.language = language
        
        # OpenAI API 설정
        self.config_dir = os.path.expanduser("~/.spatialLM")
        self.config_file = os.path.join(self.config_dir, "api_config.ini")
        self.openai_api_key = ""
        self.openai_model = "gpt-4"
        
        # API 설정 로드
        self.load_api_config()
        
        # 임시 파일 설정
        self.tmp_briefing_file = os.path.join(self.rrd_dir, f"{self.basename}_briefing_tmp.md")
        
        # 레이아웃 파일 경로 결정
        if layout_file and os.path.exists(layout_file):
            # 명시적으로 제공된 레이아웃 파일 사용
            self.layout_file = layout_file
        else:
            # 자동으로 레이아웃 파일 찾기
            # 1. 같은 이름의 텍스트 파일 확인
            possible_layout_files = [
                os.path.join(self.rrd_dir, f"{self.basename}.txt"),  # 같은 디렉토리, 같은 이름
                os.path.join(os.getcwd(), f"{self.basename}.txt"),   # 현재 디렉토리, 같은 이름
                os.path.join("layouts", f"{self.basename}.txt"),     # layouts 디렉토리
                os.path.join(os.path.dirname(self.rrd_dir), "layouts", f"{self.basename}.txt")  # 상위 디렉토리/layouts
            ]
            
            # 2. 유사한 이름의 텍스트 파일 확인 (확장자만 다른 경우)
            for ext in ['.layout', '.lay', '.map']:
                possible_layout_files.append(os.path.join(self.rrd_dir, f"{self.basename}{ext}"))
                possible_layout_files.append(os.path.join(os.getcwd(), f"{self.basename}{ext}"))
                possible_layout_files.append(os.path.join("layouts", f"{self.basename}{ext}"))
            
            # 3. 비슷한 이름의 파일 찾기 (optional_XXXX 같은 접미사 제거 시도)
            base_name_parts = self.basename.split('_')
            if len(base_name_parts) > 1:
                simpler_name = '_'.join(base_name_parts[:-1])
                for ext in ['.txt', '.layout', '.lay', '.map']:
                    possible_layout_files.append(os.path.join(self.rrd_dir, f"{simpler_name}{ext}"))
                    possible_layout_files.append(os.path.join(os.getcwd(), f"{simpler_name}{ext}"))
                    possible_layout_files.append(os.path.join("layouts", f"{simpler_name}{ext}"))
            
            # 가능한 모든 파일 중에서 존재하는 첫 번째 파일 선택
            self.layout_file = None
            for file_path in possible_layout_files:
                if os.path.exists(file_path):
                    self.layout_file = file_path
                    break
            
            # 레이아웃 파일이 없는 경우 에러 표시
            if not self.layout_file:
                error_msg = f"레이아웃 파일을 찾을 수 없습니다. '{self.basename}.txt' 파일이 현재 디렉토리에 있는지 확인하세요."
                QMessageBox.critical(self, "오류", error_msg)
                sys.exit(1)
        
        # 브리핑 파일 설정
        self.briefing_file = briefing_file
        
        # 마크다운 뷰 설정
        self.markdown_view = True
        self.qa_markdown_view = True  # 질문-답변 영역 마크다운 뷰 설정
        
        # 스트리밍 설정
        self.is_briefing_streaming = False
        self.streaming_briefing_text = ""
        
        # Q&A 히스토리 설정
        self.qa_history_list = []
        
        # 윈도우 설정
        self.setWindowTitle(f"SpatialLM 브리핑 뷰어 - {self.basename}")
        self.resize(1200, 800)  # 초기 창 크기
        self.setWindowIcon(self.create_default_icon())
        
        # 한글 폰트 설정
        self.initialize_korean_fonts()
        
        # UI 초기화
        self.init_ui()
        
        # 기존 브리핑 파일이 있으면 로드
        if self.briefing_file and os.path.exists(self.briefing_file):
            try:
                with open(self.briefing_file, 'r', encoding='utf-8') as f:
                    briefing_content = f.read()
                self.update_briefing_content(briefing_content)
                self.briefing_completed(briefing_content)
                print(f"Loaded existing briefing from {self.briefing_file}")
            except Exception as e:
                print(f"Error loading existing briefing: {e}")
                # 브리핑 생성 스레드 시작
                self.start_briefing_generation()
        else:
            # 브리핑 생성 스레드 시작
            self.start_briefing_generation()
        
        # Rerun 뷰어 시작 
        self.start_rerun_viewer()

    def initialize_korean_fonts(self):
        """한글 폰트 설정"""
        # 시스템에 설치된 폰트 확인
        font_db = QFontDatabase()
        available_fonts = font_db.families()
        print("Available fonts:", available_fonts)
        
        # 로컬 폰트 설치
        self.install_local_fonts()
        
        # 한글 지원 폰트 목록
        korean_fonts = [
            "NanumGothic", "Nanum Gothic", "Malgun Gothic", "맑은 고딕",
            "Gulim", "굴림", "Batang", "바탕", "Dotum", "돋움",
            "AppleGothic", "Apple Gothic", "Noto Sans CJK KR",
            "나눔고딕", "나눔바른고딕", "나눔스퀘어", "본고딕",
            "Source Han Sans K", "본고딕 KR"
        ]
        
        # 한글 폰트 검색
        self.korean_font = None
        for font_name in korean_fonts:
            if font_name in available_fonts:
                print(f"Found Korean font: {font_name}")
                self.korean_font = font_name
                break
        
        # 폰트를 찾지 못한 경우 기본 폰트 사용
        if not self.korean_font:
            print("No Korean font found, using default font")
            self.korean_font = QFont().family()
            
        # 기본 폰트 설정
        default_font = QFont(self.korean_font, 10)
        QApplication.setFont(default_font)
        
        print(f"Using font: {self.korean_font}")

    def install_local_fonts(self):
        """로컬 폰트 설치"""
        try:
            # 스크립트 디렉토리 찾기
            script_dir = os.path.dirname(os.path.abspath(__file__))
            
            # fonts 디렉토리에서 폰트 찾기
            fonts_dir = os.path.join(script_dir, "fonts")
            
            if os.path.exists(fonts_dir):
                for font_file in os.listdir(fonts_dir):
                    if font_file.lower().endswith(('.ttf', '.otf')):
                        font_path = os.path.join(fonts_dir, font_file)
                        font_id = QFontDatabase.addApplicationFont(font_path)
                        if font_id != -1:
                            print(f"Successfully loaded font: {font_file}")
                        else:
                            print(f"Failed to load font: {font_file}")
        except Exception as e:
            print(f"Error installing local fonts: {e}")

    def init_ui(self):
        """UI 초기화"""
        # 윈도우 설정
        self.setWindowTitle(f"SpatialLM 브리핑 뷰어 - {self.basename}")
        self.resize(1200, 800)  # 초기 창 크기
        self.setWindowIcon(self.create_default_icon())
        
        # 스타일 설정
        self.apply_modern_style()
        
        # 메인 위젯
        main_widget = QWidget()
        
        # 메인 레이아웃
        main_layout = QVBoxLayout(main_widget)
        main_layout.setContentsMargins(10, 8, 10, 10)
        main_layout.setSpacing(8)
        
        # ===== 헤더 섹션 (컴팩트하게 수정) =====
        header_container = QWidget()
        header_container.setObjectName("headerContainer")
        header_container.setStyleSheet("""
            #headerContainer {
                background-color: #ffffff;
                border-radius: 6px;
            }
        """)
        
        header_shadow = QGraphicsDropShadowEffect()
        header_shadow.setBlurRadius(8)
        header_shadow.setColor(QColor(0, 0, 0, 40))
        header_shadow.setOffset(0, 2)
        header_container.setGraphicsEffect(header_shadow)
        
        # 높이 제한 설정
        header_container.setMaximumHeight(90)
        
        header_layout = QVBoxLayout(header_container)
        header_layout.setContentsMargins(12, 8, 12, 8)
        header_layout.setSpacing(5)
        
        # 타이틀 레이아웃
        title_layout = QHBoxLayout()
        title_layout.setContentsMargins(0, 0, 0, 0)
        title_layout.setSpacing(5)
        
        # 로고/아이콘 영역 (있으면 추가)
        try:
            logo_path = os.path.join(script_dir, "assets", "logo.png")
            if os.path.exists(logo_path):
                logo_label = QLabel()
                logo_pixmap = QPixmap(logo_path)
                logo_label.setPixmap(logo_pixmap.scaled(24, 24, Qt.KeepAspectRatio, Qt.SmoothTransformation))
                title_layout.addWidget(logo_label)
        except:
            pass
        
        # 제목 레이블 (크기 축소)
        header_title = QLabel(f"IIFA AI 지휘결심지원체계 (차세대C5시스템과 프로토타입)")
        header_title.setFont(QFont(self.korean_font, 14, QFont.Bold))
        header_title.setStyleSheet("color: #2c3e50;")
        title_layout.addWidget(header_title)
        
        # 파일명 표시 (작게)
        filename_label = QLabel(f"{self.basename}")
        filename_label.setFont(QFont(self.korean_font, 11))
        filename_label.setStyleSheet("color: #7f8c8d;")
        title_layout.addWidget(filename_label)
        
        title_layout.addStretch(1)
        
        # 언어 선택 콤보박스
        language_layout = QHBoxLayout()
        language_label = QLabel("언어:")
        language_label.setFont(QFont(self.korean_font, 9))
        language_label.setStyleSheet("color: #7f8c8d;")
        
        self.language_combo = QComboBox()
        self.language_combo.addItems(["한국어", "English"])
        self.language_combo.setCurrentIndex(0 if self.language == "korean" else 1)
        self.language_combo.currentIndexChanged.connect(self.change_language)
        self.language_combo.setFixedWidth(80)
        self.language_combo.setFont(QFont(self.korean_font, 9))
        self.language_combo.setStyleSheet("""
            QComboBox {
                border: 1px solid #e0e0e0;
                border-radius: 3px;
                padding: 2px 5px;
                background-color: #f8f9fa;
                color: #2c3e50;
            }
            QComboBox::drop-down {
                border: 0px;
                width: 15px;
            }
            QComboBox::down-arrow {
                width: 10px;
                height: 10px;
            }
            QComboBox QAbstractItemView {
                border: 1px solid #e0e0e0;
                selection-background-color: #3498db;
            }
        """)
        
        language_layout.addWidget(language_label)
        language_layout.addWidget(self.language_combo)
        
        title_layout.addLayout(language_layout)
        header_layout.addLayout(title_layout)
        
        # 상태 표시 및 진행률
        status_layout = QHBoxLayout()
        status_layout.setContentsMargins(0, 0, 0, 0)
        status_layout.setSpacing(5)
        
        status_icon_label = QLabel()
        status_icon_label.setFixedSize(12, 12)
        status_layout.addWidget(status_icon_label)
        
        self.status_label = QLabel("브리핑 생성 중...")
        self.status_label.setFont(QFont(self.korean_font, 10))
        self.status_label.setStyleSheet("color: #7f8c8d; margin-left: 2px;")
        status_layout.addWidget(self.status_label)
        
        status_layout.addStretch(1)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setFixedWidth(300)  # 200에서 300으로 너비 증가
        self.progress_bar.setFixedHeight(20)  # 12에서 20으로 높이 증가
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: none;
                border-radius: 5px;
                background-color: #f0f0f0;
                height: 20px;
                text-align: center;
                font-size: 12px;
                font-weight: bold;
                color: #2c3e50;
            }
            QProgressBar::chunk {
                background-color: #3498db;
                border-radius: 5px;
            }
        """)
        
        status_layout.addWidget(self.progress_bar)
        header_layout.addLayout(status_layout)
        
        main_layout.addWidget(header_container)
        
        # ===== 스플리터 생성 (좌우 분할) - 더 큰 공간 배정 =====
        splitter = QSplitter(Qt.Horizontal)
        splitter.setHandleWidth(6)
        splitter.setStyleSheet("""
            QSplitter::handle {
                background-color: #e0e0e0;
                border: 1px solid #cccccc;
                border-radius: 2px;
            }
            QSplitter::handle:hover {
                background-color: #3498db;
            }
        """)
        
        # 스플리터에 더 많은 비중 설정 (메인 영역이 더 크게 표시되도록)
        main_layout.addWidget(splitter, 1)  # 늘어나는 공간 모두 할당
        
        # ===== 왼쪽 컨테이너 (브리핑 정보) =====
        left_container = QWidget()
        left_layout = QVBoxLayout(left_container)
        left_layout.setContentsMargins(0, 0, 5, 0)
        left_layout.setSpacing(10)
        
        # 브리핑 정보 섹션 (좌측)
        briefing_container = QWidget()
        briefing_container.setObjectName("briefingContainer")
        briefing_container.setStyleSheet("""
            #briefingContainer {
                background-color: #ffffff;
                border-radius: 8px;
            }
        """)
        
        briefing_shadow = QGraphicsDropShadowEffect()
        briefing_shadow.setBlurRadius(10)
        briefing_shadow.setColor(QColor(0, 0, 0, 40))
        briefing_shadow.setOffset(0, 2)
        briefing_container.setGraphicsEffect(briefing_shadow)
        
        briefing_layout = QVBoxLayout(briefing_container)
        briefing_layout.setContentsMargins(15, 12, 15, 12)
        briefing_layout.setSpacing(8)
        
        # 브리핑 제목
        briefing_title = QLabel("브리핑 정보")
        briefing_title.setFont(QFont(self.korean_font, 12, QFont.Bold))
        briefing_title.setStyleSheet("color: #2c3e50; margin-bottom: 2px;")
        briefing_layout.addWidget(briefing_title)
        
        # 브리핑 콘텐츠 영역 (여백 축소)
        self.briefing_text = QTextEdit()
        self.briefing_text.setFont(QFont(self.korean_font, 11))
        self.briefing_text.setReadOnly(True)
        self.briefing_text.setAcceptRichText(True)
        self.briefing_text.setStyleSheet("""
            QTextEdit {
                border: 1px solid #e0e0e0;
                border-radius: 5px;
                padding: 12px;
                color: #2c3e50;
                background-color: #fafafa;
            }
        """)
        
        placeholder_text = "브리핑 정보를 생성하는 중입니다...\n\n이 작업은 장면의 복잡성에 따라 몇 분 정도 소요될 수 있습니다."
        self.briefing_text.setPlaceholderText(placeholder_text)
        briefing_layout.addWidget(self.briefing_text)
        
        # 브리핑 컨트롤 섹션
        briefing_controls = QHBoxLayout()
        
        # 저장 버튼
        self.save_button = QPushButton(" 브리핑 저장")
        self.save_button.setFont(QFont(self.korean_font, 11))
        self.save_button.setEnabled(False)
        self.save_button.clicked.connect(self.save_briefing)
        self.save_button.setCursor(Qt.PointingHandCursor)
        self.save_button.setStyleSheet("""
            QPushButton {
                background-color: #3498db;
                color: white;
                border-radius: 5px;
                padding: 8px 15px;
                font-weight: bold;
                border: none;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
            QPushButton:pressed {
                background-color: #1f6dad;
            }
            QPushButton:disabled {
                background-color: #bdc3c7;
            }
        """)
        
        # 뷰 전환 버튼
        self.toggle_view_button = QPushButton("🔄 텍스트 보기")
        self.toggle_view_button.setFont(QFont(self.korean_font, 11))
        self.toggle_view_button.setEnabled(False)
        self.toggle_view_button.clicked.connect(self.toggle_view)
        self.toggle_view_button.setCursor(Qt.PointingHandCursor)
        self.toggle_view_button.setStyleSheet("""
            QPushButton {
                background-color: #95a5a6;
                color: white;
                border-radius: 5px;
                padding: 8px 15px;
                font-weight: bold;
                border: none;
            }
            QPushButton:hover {
                background-color: #7f8c8d;
            }
            QPushButton:pressed {
                background-color: #6c7778;
            }
            QPushButton:disabled {
                background-color: #bdc3c7;
            }
        """)
        
        # 폰트 크기 조절 버튼
        font_size_layout = QHBoxLayout()
        
        self.decrease_font_button = QPushButton("A-")
        self.decrease_font_button.setFixedSize(30, 30)
        self.decrease_font_button.clicked.connect(self.decrease_font)
        self.decrease_font_button.setCursor(Qt.PointingHandCursor)
        
        self.increase_font_button = QPushButton("A+")
        self.increase_font_button.setFixedSize(30, 30)
        self.increase_font_button.clicked.connect(self.increase_font)
        self.increase_font_button.setCursor(Qt.PointingHandCursor)
        
        font_size_layout.addWidget(self.decrease_font_button)
        font_size_layout.addWidget(self.increase_font_button)
        font_size_layout.setSpacing(5)
        
        briefing_controls.addWidget(self.save_button)
        briefing_controls.addWidget(self.toggle_view_button)
        briefing_controls.addStretch(1)
        briefing_controls.addLayout(font_size_layout)
        
        briefing_layout.addLayout(briefing_controls)
        left_layout.addWidget(briefing_container)
        
        # ===== 오른쪽 컨테이너 (QA 섹션) =====
        right_container = QWidget()
        right_layout = QVBoxLayout(right_container)
        right_layout.setContentsMargins(5, 0, 0, 0)
        right_layout.setSpacing(10)
        
        # QA 섹션 (우측)
        qa_container = QWidget()
        qa_container.setObjectName("qaContainer")
        qa_container.setStyleSheet("""
            #qaContainer {
                background-color: #ffffff;
                border-radius: 8px;
            }
        """)
        
        qa_shadow = QGraphicsDropShadowEffect()
        qa_shadow.setBlurRadius(10)
        qa_shadow.setColor(QColor(0, 0, 0, 40))
        qa_shadow.setOffset(0, 2)
        qa_container.setGraphicsEffect(qa_shadow)
        
        qa_layout = QVBoxLayout(qa_container)
        qa_layout.setContentsMargins(15, 15, 15, 15)
        qa_layout.setSpacing(10)
        
        # 질문-답변 섹션 헤더 레이아웃
        qa_header_layout = QHBoxLayout()
        
        # 질문-답변 섹션 타이틀
        qa_title = QLabel("실시간 전투지휘지원")
        qa_title.setFont(QFont(self.korean_font, 14, QFont.Bold))
        qa_title.setStyleSheet("color: #2c3e50; margin-bottom: 5px;")
        qa_header_layout.addWidget(qa_title)
        
        qa_header_layout.addStretch(1)
        
        # 모델 레이블 제거 (나중에 다른 위치로 이동)
        # self.model_label = QLabel(f"모델: {self.openai_model}")
        # self.model_label.setFont(QFont(self.korean_font, 10))
        # self.model_label.setStyleSheet("color: #7f8c8d; margin-right: 10px;")
        # qa_header_layout.addWidget(self.model_label)
        
        # API 키 설정 버튼
        self.api_settings_button = QPushButton("API 설정")
        self.api_settings_button.setFont(QFont(self.korean_font, 10))
        self.api_settings_button.setCursor(Qt.PointingHandCursor)
        self.api_settings_button.clicked.connect(self.show_api_settings)
        self.api_settings_button.setStyleSheet("""
            QPushButton {
                background-color: #7f8c8d;
                color: white;
                border-radius: 4px;
                padding: 4px 8px;
                font-weight: bold;
                border: none;
            }
            QPushButton:hover {
                background-color: #6c7778;
            }
        """)
        
        # 답변 뷰 전환 버튼 (마크다운/텍스트)
        self.qa_toggle_view_button = QPushButton("🔄 텍스트 보기")
        self.qa_toggle_view_button.setFont(QFont(self.korean_font, 10))
        self.qa_toggle_view_button.setCursor(Qt.PointingHandCursor)
        self.qa_toggle_view_button.clicked.connect(self.toggle_qa_view)
        self.qa_toggle_view_button.setStyleSheet("""
            QPushButton {
                background-color: #3498db;
                color: white;
                border-radius: 4px;
                padding: 4px 8px;
                font-weight: bold;
                border: none;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
        """)
        
        # 버튼들을 나란히 배치 (API 설정 버튼 옆에 마크다운/텍스트 전환 버튼)
        qa_header_layout.addWidget(self.api_settings_button)
        qa_header_layout.addWidget(self.qa_toggle_view_button)
        
        qa_layout.addLayout(qa_header_layout)
        
        # 질문-답변 기록 영역
        self.qa_history = QTextEdit()
        self.qa_history.setFont(QFont(self.korean_font, 11))
        self.qa_history.setReadOnly(True)
        self.qa_history.setAcceptRichText(True)
        self.qa_history.setStyleSheet("""
            QTextEdit {
                border: 1px solid #e0e0e0;
                border-radius: 5px;
                padding: 10px;
                color: #2c3e50;
                background-color: #f5f5f5;
            }
        """)
        self.qa_history.setPlaceholderText("여기에 질문과 답변 기록이 표시됩니다. 브리핑이 완료된 후 질문할 수 있습니다.")
        qa_layout.addWidget(self.qa_history)
        
        # 질문 입력 및 제출 영역
        question_layout = QHBoxLayout()
        
        self.question_input = QTextEdit()
        self.question_input.setFont(QFont(self.korean_font, 11))
        self.question_input.setAcceptRichText(False)
        self.question_input.setStyleSheet("""
            QTextEdit {
                border: 1px solid #e0e0e0;
                border-radius: 5px;
                padding: 10px;
                color: #2c3e50;
                background-color: #ffffff;
            }
        """)
        self.question_input.setPlaceholderText("공간에 대해 질문하세요... 시각화가 필요한 경우 요청코드를 입력하세요.")
        self.question_input.setMaximumHeight(80)
        self.question_input.setEnabled(False)
        
        self.submit_question_button = QPushButton("질문하기")
        self.submit_question_button.setEnabled(False)
        self.submit_question_button.setFont(QFont(self.korean_font, 11))
        self.submit_question_button.setCursor(Qt.PointingHandCursor)
        self.submit_question_button.setStyleSheet("""
            QPushButton {
                background-color: #2ecc71;
                color: white;
                border-radius: 5px;
                padding: 8px 15px;
                font-weight: bold;
                border: none;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #27ae60;
            }
            QPushButton:pressed {
                background-color: #1e8449;
            }
            QPushButton:disabled {
                background-color: #bdc3c7;
            }
        """)
        self.submit_question_button.clicked.connect(self.submit_question)
        self.submit_question_button.setEnabled(False)
        
        question_layout.addWidget(self.question_input, 4)
        question_layout.addWidget(self.submit_question_button, 1)
        
        qa_layout.addLayout(question_layout)
        
        # 모델 레이블 추가 - 질문 입력칸 아래에 배치
        self.model_label = QLabel(f"모델: {self.openai_model}")
        self.model_label.setFont(QFont(self.korean_font, 10))
        self.model_label.setStyleSheet("color: #7f8c8d; margin-top: 5px;")
        qa_layout.addWidget(self.model_label)
        
        right_layout.addWidget(qa_container)
        
        # 스플리터에 좌우 컨테이너 추가
        splitter.addWidget(left_container)
        splitter.addWidget(right_container)
        
        # 초기 분할 비율 설정 (50:50)
        splitter.setSizes([int(self.width() * 0.5), int(self.width() * 0.5)])
        
        # 메인 레이아웃에 스플리터 추가
        main_layout.addWidget(splitter)
        
        # 메인 위젯 설정
        self.setCentralWidget(main_widget)
        
        # 마크다운 CSS 설정
        self.markdown_css = """
        <style>
            body {
                font-family: "{}";
                line-height: 1.4;
                color: #2c3e50;
                padding: 0;
                margin: 0;
            }
            h1, h2, h3, h4, h5, h6 {
                color: #34495e;
                margin-top: 16px;
                margin-bottom: 12px;
                font-weight: 600;
            }
            h1 { font-size: 1.8em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
            h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
            h3 { font-size: 1.3em; }
            p { margin-bottom: 12px; }
            ul, ol { padding-left: 2em; margin-bottom: 12px; margin-top: 6px; }
            li { margin-bottom: 0.2em; }
            table {
                border-collapse: collapse;
                margin-bottom: 16px;
                width: 100%;
            }
            th, td {
                border: 1px solid #dfe2e5;
                padding: 6px 13px;
            }
            th {
                background-color: #f6f8fa;
            }
            code {
                font-family: "Courier New", Courier, monospace;
                background-color: #f6f8fa;
                padding: 0.2em 0.4em;
                border-radius: 3px;
            }
            pre {
                background-color: #f6f8fa;
                padding: 16px;
                border-radius: 3px;
                overflow: auto;
            }
            pre code {
                background-color: transparent;
                padding: 0;
            }
            blockquote {
                margin-left: 0;
                padding-left: 1em;
                border-left: 4px solid #dfe2e5;
                color: #6a737d;
            }
            hr {
                height: 0.25em;
                padding: 0;
                margin: 24px 0;
                background-color: #e1e4e8;
                border: 0;
            }
            .question {
                background-color: #f0f8ff;
                border-left: 4px solid #3498db;
                padding: 10px;
                margin-bottom: 15px;
            }
            .answer {
                background-color: #f7fdfa;
                border-left: 4px solid #2ecc71;
                padding: 10px;
                margin-bottom: 15px;
            }
        </style>
        """
        
        # 상태바 추가
        self.statusBar = QStatusBar()
        self.setStatusBar(self.statusBar)
        self.statusBar.showMessage("준비 완료")
        
        # 마크다운 뷰 설정
        self.markdown_view = True
        self.qa_markdown_view = True
        
        # 창 표시
        self.show()

    def create_default_icon(self):
        """기본 아이콘 생성"""
        # 픽셀 아트 스타일의 간단한 아이콘 생성
        pixmap = QPixmap(32, 32)
        pixmap.fill(Qt.transparent)
        
        # 아이콘 그리기
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 배경 원 그리기
        painter.setPen(Qt.NoPen)
        painter.setBrush(QBrush(QColor(52, 152, 219)))  # 파란색 배경
        painter.drawEllipse(2, 2, 28, 28)
        
        # 간단한 지도/레이아웃 아이콘 그리기
        painter.setPen(QPen(QColor(255, 255, 255), 2))  # 흰색 선
        painter.drawLine(10, 10, 22, 10)  # 상단 선
        painter.drawLine(10, 16, 22, 16)  # 중간 선
        painter.drawLine(10, 22, 22, 22)  # 하단 선
        
        painter.drawLine(8, 8, 8, 24)     # 왼쪽 세로선
        painter.drawLine(24, 8, 24, 24)   # 오른쪽 세로선
        
        # 그리기 종료
        painter.end()
        
        # QIcon 객체 생성하여 반환
        return QIcon(pixmap)

    def apply_modern_style(self):
        """애플리케이션에 모던한 스타일 적용"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f5f6fa;
            }
            
            QLabel {
                color: #2c3e50;
            }
            
            QPushButton {
                border-radius: 4px;
                padding: 8px 15px;
                background-color: #3498db;
                color: white;
                font-weight: bold;
            }
            
            QPushButton:hover {
                background-color: #2980b9;
            }
            
            QPushButton:disabled {
                background-color: #bdc3c7;
                color: #7f8c8d;
            }
            
            QComboBox {
                border: 1px solid #dcdde1;
                border-radius: 4px;
                padding: 5px;
                background-color: white;
            }
            
            QTextEdit {
                background-color: white;
                border: 1px solid #dcdde1;
                border-radius: 4px;
            }
            
            QProgressBar {
                text-align: center;
                background-color: #f0f0f0;
                border-radius: 4px;
                height: 10px;
            }
            
            QProgressBar::chunk {
                background-color: #3498db;
                border-radius: 4px;
            }
        """)

    def start_briefing_generation(self):
        """브리핑 생성 스레드 시작"""
        # API 키 확인
        if not self.openai_api_key:
            # API 키가 없으면 설정 대화 상자 표시
            self.show_api_settings()
            if not self.openai_api_key:
                QMessageBox.warning(self, "API 키 필요", "브리핑을 생성하려면 OpenAI API 키가 필요합니다.")
                self.status_label.setText("브리핑 생성 취소됨 - API 키 없음")
                self.progress_bar.setValue(0)
                return
        
        # ChatGPT를 사용하여 브리핑 생성
        self.briefing_thread = ChatGPTBriefingThread(
            self.layout_file, 
            self.tmp_briefing_file, 
            self.model_path, 
            self.openai_api_key,
            self.openai_model,
            self.language
        )
        
        # 브리핑 스트리밍 출력을 위한 변수 초기화
        self.streaming_briefing_text = ""
        self.is_briefing_streaming = True
        
        self.status_label.setText("ChatGPT로 브리핑 생성 중...")
            
        self.briefing_thread.update_signal.connect(self.update_briefing_content)
        self.briefing_thread.finished_signal.connect(self.briefing_completed)
        self.briefing_thread.error_signal.connect(self.briefing_error)
        self.briefing_thread.progress_signal.connect(self.update_progress)
        
        # 실시간 스트리밍 시그널 연결
        self.briefing_thread.stream_signal.connect(self.update_streaming_briefing)
            
        self.briefing_thread.start()

    def start_rerun_viewer(self):
        """Rerun 뷰어 스레드 시작"""
        self.rerun_thread = RerunViewerThread(self.rrd_file)
        self.rerun_thread.error_signal.connect(self.rerun_error)
        self.rerun_thread.start()

    def update_briefing_content(self, text):
        """브리핑 내용 업데이트"""
        if text:
            # 텍스트 저장
            self.markdown_content = text
            
            # 상태 업데이트
            self.status_label.setText("브리핑 생성 완료!")
            self.progress_bar.setValue(100)
            
            # 버튼 활성화
            self.save_button.setEnabled(True)
            self.toggle_view_button.setEnabled(True)
            
            # 질문 입력 활성화
            self.question_input.setEnabled(True)
            self.submit_question_button.setEnabled(True)
            
            # 마크다운 렌더링
            if self.markdown_view:
                self.render_markdown()
            else:
                self.briefing_text.setPlainText(text)
                
            # QA 히스토리 복원 (항상 복원)
            self.restore_qa_history()
        else:
            # 내용이 없는 경우 에러 메시지 표시
            error_html = """
            <div style="text-align:center; padding:20px; color:#e74c3c;">
                <h3>브리핑 생성 실패</h3>
                <p>브리핑 내용을 생성하는 동안 오류가 발생했습니다.</p>
                <p>다시 시도하거나 다른 RRD 파일을 선택해주세요.</p>
            </div>
            """
            self.briefing_text.setHtml(error_html)
            self.status_label.setText("브리핑 생성 실패")
            self.progress_bar.setValue(0)

    def briefing_completed(self, content):
        """브리핑 생성 완료 처리"""
        # 스트리밍 종료
        self.is_briefing_streaming = False
        
        # 마크다운 콘텐츠 저장
        self.markdown_content = content
        
        # 상태 업데이트
        self.status_label.setText("브리핑 생성 완료!")
        self.progress_bar.setValue(100)
        
        # 버튼 활성화
        self.save_button.setEnabled(True)
        self.toggle_view_button.setEnabled(True)
        
        # 질문 입력 활성화
        self.question_input.setEnabled(True)
        self.submit_question_button.setEnabled(True)
        
        # 마크다운 렌더링 (스트리밍 중에 이미 렌더링된 경우에도 최종 내용으로 다시 렌더링)
        if self.markdown_view:
            self.render_markdown()
        else:
            self.briefing_text.setPlainText(content)
            
        # QA 히스토리 복원
        self.restore_qa_history()

    def briefing_error(self, error):
        """브리핑 생성 오류"""
        self.progress_bar.setValue(0)
        self.status_label.setText("브리핑 생성 오류")
        
        self.briefing_text.clear()
        self.briefing_text.setText(f"브리핑 생성 중 오류가 발생했습니다:\n\n{error}\n\n레이아웃 파일이 올바르고 유효한지 확인하세요.")
        
        QMessageBox.critical(self, "오류", f"브리핑 생성 오류: {error}")

    def rerun_error(self, error):
        """Rerun 뷰어 실행 오류"""
        QMessageBox.warning(self, "경고", f"Rerun 뷰어 실행 오류: {error}")

    def update_progress(self, value):
        """진행 상태 업데이트"""
        self.progress_bar.setValue(value)
        
        # 진행 상태에 따른 메시지 업데이트
        if value < 25:
            msg = "장면 분석 중..."
        elif value < 50:
            msg = "객체 정보 처리 중..."
        elif value < 75:
            msg = "브리핑 초안 생성 중..."
        else:
            msg = "최종 브리핑 완성 중..."
            
        self.status_label.setText(msg)

    def convert_markdown_to_html(self, md_text):
        """마크다운 텍스트를 HTML로 변환"""
        try:
            # 마크다운 확장 옵션 설정
            extensions = [
                'markdown.extensions.tables',
                'markdown.extensions.fenced_code',
                'markdown.extensions.codehilite',
                'markdown.extensions.nl2br',
                'markdown.extensions.sane_lists'
            ]
            
            # 마크다운을 HTML로 변환
            html = markdown.markdown(md_text, extensions=extensions)
            
            # CSS에 폰트 이름 직접 적용
            css_with_font = self.markdown_css.replace("{}", self.korean_font)
            
            # 최종 HTML 문서 생성 (CSS 스타일 포함)
            complete_html = f"""
            <html>
                <head>
                    {css_with_font}
                </head>
                <body>
                    {html}
                </body>
            </html>
            """
            
            return complete_html
        except Exception as e:
            print(f"마크다운 변환 오류: {str(e)}")
            return f"<p>마크다운 변환 오류: {str(e)}</p><pre>{md_text}</pre>"

    def render_markdown(self):
        """마크다운 텍스트를 HTML로 렌더링하여 표시"""
        if not hasattr(self, 'markdown_content') or not self.markdown_content:
            return
            
        # 현재 폰트 이름과 크기 가져오기
        font = self.briefing_text.font()
        font_name = font.family()
        font_size = font.pointSize()
        
        # 마크다운을 HTML로 변환
        html_content = markdown.markdown(
            self.markdown_content, 
            extensions=['tables', 'fenced_code', 'codehilite', 'nl2br', 'sane_lists']
        )
        
        # CSS에 폰트 직접 지정
        css = self.markdown_css.replace('"{}"', f'"{font_name}"')
        
        # HTML 설정
        self.briefing_text.setHtml(css + html_content)
        
        # 질문-답변 히스토리 복원
        self.restore_qa_history()

    def toggle_view(self):
        """마크다운 뷰와 일반 텍스트 뷰 전환"""
        if self.markdown_view:
            # 마크다운 → 텍스트 전환
            self.markdown_view = False
            self.toggle_view_button.setText("🔄 마크다운 보기")
            self.briefing_text.setPlainText(self.markdown_content)
        else:
            # 텍스트 → 마크다운 전환
            self.markdown_view = True
            self.toggle_view_button.setText("🔄 텍스트 보기")
            self.render_markdown()

    def save_briefing(self):
        """브리핑 저장"""
        try:
            # 파일 저장 대화상자
            options = QFileDialog.Options()
            
            # 저장 형식 선택 (마크다운/HTML/텍스트)
            file_filter = "마크다운 파일 (*.md);;HTML 파일 (*.html);;텍스트 파일 (*.txt)"
            default_filename = f"{self.basename}_briefing.md" if self.markdown_view else f"{self.basename}_briefing.txt"
            
            file_path, selected_filter = QFileDialog.getSaveFileName(
                self, "브리핑 저장", default_filename, 
                file_filter, options=options
            )
            
            if file_path:
                if selected_filter == "HTML 파일 (*.html)":
                    # HTML로 저장
                    html_content = self.convert_markdown_to_html(self.markdown_content)
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(html_content)
                elif selected_filter == "마크다운 파일 (*.md)":
                    # 마크다운으로 저장
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(self.markdown_content)
                else:
                    # 일반 텍스트로 저장
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(self.markdown_content)
                
                QMessageBox.information(self, "저장 완료", f"브리핑이 저장되었습니다: {file_path}")
        except Exception as e:
            QMessageBox.critical(self, "저장 오류", f"파일 저장 중 오류가 발생했습니다: {str(e)}")

    def increase_font(self):
        """폰트 크기 증가"""
        current_font = self.briefing_text.font()
        size = current_font.pointSize()
        if size < 24:  # 최대 크기 제한
            current_font.setPointSize(size + 1)
            self.briefing_text.setFont(current_font)
            # 마크다운 뷰일 경우 다시 렌더링
            if self.markdown_view and hasattr(self, 'markdown_content') and self.markdown_content:
                self.render_markdown()
    
    def decrease_font(self):
        """폰트 크기 감소"""
        current_font = self.briefing_text.font()
        size = current_font.pointSize()
        if size > 8:  # 최소 크기 제한
            current_font.setPointSize(size - 1)
            self.briefing_text.setFont(current_font)
            # 마크다운 뷰일 경우 다시 렌더링
            if self.markdown_view and hasattr(self, 'markdown_content') and self.markdown_content:
                self.render_markdown()

    def change_language(self, index):
        """언어 변경"""
        new_language = "korean" if index == 0 else "english"
        if new_language != self.language:
            reply = QMessageBox.question(self, "언어 변경", 
                                        "언어를 변경하면 브리핑이 다시 생성됩니다. 계속하시겠습니까?",
                                        QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                self.language = new_language
                self.progress_bar.setValue(0)
                self.status_label.setText("브리핑 생성 중...")
                self.briefing_text.clear()
                self.briefing_text.setPlaceholderText("브리핑 정보를 생성하는 중입니다...")
                self.save_button.setEnabled(False)
                
                # 브리핑 다시 생성
                self.start_briefing_generation()
            else:
                # 변경 취소
                self.language_combo.setCurrentIndex(0 if self.language == "korean" else 1)

    def closeEvent(self, event):
        """창 닫기 이벤트"""
        # 임시 파일 삭제
        try:
            if os.path.exists(self.tmp_briefing_file):
                os.unlink(self.tmp_briefing_file)
        except:
            pass
        
        # 기본 이벤트 처리
        super().closeEvent(event)

    def show_api_settings(self):
        """API 설정 다이얼로그 표시"""
        dialog = ApiKeyDialog(self, self.openai_api_key)
        
        # 현재 모델 선택
        model_index = dialog.model_combo.findText(self.openai_model)
        if model_index >= 0:
            dialog.model_combo.setCurrentIndex(model_index)
        
        if dialog.exec_() == QDialog.Accepted:
            # 새 설정 저장
            self.openai_api_key = dialog.get_api_key()
            self.openai_model = dialog.get_model()
            self.save_api_config()
            
            # 모델 레이블 업데이트
            self.model_label.setText(f"모델: {self.openai_model}")
            
            api_status = "API 키가 설정됨" if self.openai_api_key else "API 키가 설정되지 않음"
            self.statusBar.showMessage(f"API 설정이 저장되었습니다. ({api_status})")
    
    def load_api_config(self):
        """API 설정 로드"""
        try:
            # 설정 디렉토리 생성 (없는 경우)
            if not os.path.exists(self.config_dir):
                os.makedirs(self.config_dir)
            
            # 설정 파일 로드
            if os.path.exists(self.config_file):
                config = configparser.ConfigParser()
                config.read(self.config_file)
                
                if 'OpenAI' in config:
                    self.openai_api_key = config['OpenAI'].get('api_key', '')
                    self.openai_model = config['OpenAI'].get('model', 'gpt-4')
                    
                    # 모델 레이블이 이미 초기화되었으면 업데이트
                    if hasattr(self, 'model_label'):
                        self.model_label.setText(f"모델: {self.openai_model}")
        except Exception as e:
            print(f"설정 로드 오류: {str(e)}")
    
    def save_api_config(self):
        """API 설정 저장"""
        try:
            # 설정 디렉토리 생성 (없는 경우)
            if not os.path.exists(self.config_dir):
                os.makedirs(self.config_dir)
            
            # 설정 파일 저장
            config = configparser.ConfigParser()
            config['OpenAI'] = {
                'api_key': self.openai_api_key,
                'model': self.openai_model
            }
            
            with open(self.config_file, 'w') as f:
                config.write(f)
                
            print(f"API 설정이 저장되었습니다: {self.config_file}")
        except Exception as e:
            print(f"설정 저장 오류: {str(e)}")
            
    def show_qa_error(self, error):
        """질문-답변 오류 표시"""
        # 오류 메시지 HTML 생성
        error_html = f"""<div style="color: #e74c3c; margin: 10px 0;"><strong>⚠️ 오류:</strong> {error}</div>"""
        
        # 오류 메시지 히스토리에 추가
        self.qa_history.append(error_html)
        
        # 히스토리 리스트에 오류 저장
        self.qa_history_list.append({
            "type": "error",
            "content": error,
            "timestamp": datetime.now().strftime("%H:%M:%S"),
            "html": error_html
        })
        
        # UI 다시 활성화
        self.question_input.setEnabled(True)
        self.submit_question_button.setEnabled(True)
        self.submit_question_button.setText("질문하기")
        self.statusBar.showMessage("질문 처리 오류")
        
        # 히스토리 스크롤을 맨 아래로 이동
        self.qa_history.verticalScrollBar().setValue(
            self.qa_history.verticalScrollBar().maximum()
        )

    def submit_question(self):
        """질문 제출 및 처리"""
        # 질문 텍스트 가져오기
        question = self.question_input.toPlainText().strip()
        
        # 질문이 비어있는지 확인
        if not question:
            self.statusBar.showMessage("질문을 입력해주세요.")
            return
        
        # API 키 확인
        if not self.openai_api_key:
            reply = QMessageBox.question(
                self, "API 키 필요", 
                "질문에 답변하려면 OpenAI API 키가 필요합니다. API 설정 창을 여시겠습니까?",
                QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes
            )
            if reply == QMessageBox.Yes:
                self.show_api_settings()
                return
        
        # UI 상태 업데이트
        self.question_input.setEnabled(False)
        self.submit_question_button.setEnabled(False)
        self.submit_question_button.setText("처리 중...")
        self.statusBar.showMessage("질문 처리 중...")
        
        # 타임스탬프 추가
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # 히스토리 리스트에 질문 저장
        self.qa_history_list.append({
            "type": "question",
            "content": question,
            "timestamp": timestamp
        })
        
        # 히스토리 리스트에 스트리밍 응답 준비
        self.qa_history_list.append({
            "type": "streaming",
            "content": "응답을 준비 중입니다...",
            "timestamp": datetime.now().strftime("%H:%M:%S")
        })
        
        # 마크다운/텍스트 모드에 따라 다르게 렌더링
        if hasattr(self, 'qa_markdown_view') and self.qa_markdown_view:
            self.render_qa_history()
        else:
            # 텍스트 모드
            plain_text = ""
            for item in self.qa_history_list:
                if item["type"] == "question":
                    plain_text += f"질문: {item['content']}\n\n"
                elif item["type"] == "answer":
                    plain_text += f"답변: {item['content']}\n\n"
                elif item["type"] == "streaming":
                    plain_text += f"답변 중...\n{item['content']}\n\n"
                elif item["type"] == "error":
                    plain_text += f"오류: {item['content']}\n\n"
            
            self.qa_history.setPlainText(plain_text)
        
        # 히스토리 스크롤을 맨 아래로 이동
        self.qa_history.verticalScrollBar().setValue(
            self.qa_history.verticalScrollBar().maximum()
        )
        
        # 현재까지의 브리핑 내용 가져오기
        if hasattr(self, 'markdown_content'):
            briefing_content = self.markdown_content
        else:
            briefing_content = self.briefing_text.toPlainText()
        
        # 스트리밍 변수 초기화
        self.streaming_answer = ""
        self.is_answer_streaming = True
        
        # ChatGPT API 호출 쓰레드 시작
        self.qa_thread = QAThread(
            self.layout_file,
            briefing_content,
            question,
            self.openai_api_key,
            self.openai_model,
            self.language
        )
        
        # 시그널 연결
        self.qa_thread.answer_signal.connect(self.show_answer)
        self.qa_thread.error_signal.connect(self.show_qa_error)
        self.qa_thread.stream_signal.connect(self.update_streaming_answer)
        self.qa_thread.code_generated_signal.connect(self.handle_generated_code)  # 새로운 시그널 연결
        
        # 쓰레드 시작
        self.qa_thread.start()
        
        # 입력 필드 초기화
        self.question_input.clear()
    
    def update_streaming_answer(self, text_chunk):
        """답변 스트리밍 실시간 업데이트"""
        # 특수 문자 이스케이프 처리
        escaped_chunk = text_chunk.replace("<", "&lt;").replace(">", "&gt;")
        
        # 현재 스트리밍 텍스트에 추가
        self.streaming_answer += escaped_chunk
        
        # 마크다운/텍스트 모드에 따라 다르게 업데이트
        if hasattr(self, 'qa_markdown_view') and self.qa_markdown_view:
            # 스트리밍 내용을 마지막 항목으로 임시 저장
            if len(self.qa_history_list) > 0 and self.qa_history_list[-1]["type"] == "streaming":
                # 기존 스트리밍 항목 업데이트
                self.qa_history_list[-1]["content"] = self.streaming_answer
            else:
                # 새로운 스트리밍 항목 추가
                self.qa_history_list.append({
                    "type": "streaming", 
                    "content": self.streaming_answer,
                    "timestamp": datetime.now().strftime("%H:%M:%S")
                })
            
            # 전체 히스토리 다시 렌더링
            self.render_qa_history()
        else:
            # 텍스트 모드
            # 현재 텍스트 업데이트
            plain_text = ""
            for item in self.qa_history_list:
                if item["type"] == "question":
                    plain_text += f"질문: {item['content']}\n\n"
                elif item["type"] == "answer":
                    plain_text += f"답변: {item['content']}\n\n"
                elif item["type"] == "error":
                    plain_text += f"오류: {item['content']}\n\n"
            
            # 현재 스트리밍 중인 응답 추가
            plain_text += f"답변 중...\n{self.streaming_answer}\n"
            
            # 텍스트 업데이트
            self.qa_history.setPlainText(plain_text)
        
        # 스크롤을 항상 최하단으로 유지
        self.qa_history.verticalScrollBar().setValue(
            self.qa_history.verticalScrollBar().maximum()
        )

    def show_answer(self, answer):
        """최종 답변 표시 및 마크다운 적용"""
        # 스트리밍 모드 종료
        self.is_answer_streaming = False
        
        try:
            # 응답 시간 기록
            timestamp = datetime.now().strftime("%H:%M:%S")
            
            # 스트리밍 항목 제거 (있는 경우)
            for i in range(len(self.qa_history_list) - 1, -1, -1):
                if self.qa_history_list[i]["type"] == "streaming":
                    del self.qa_history_list[i]
                    break
            
            # 히스토리 리스트에 답변 저장
            self.qa_history_list.append({
                "type": "answer",
                "content": answer,
                "timestamp": timestamp
            })
            
            # 마크다운/텍스트 모드에 따라 다르게 렌더링
            if hasattr(self, 'qa_markdown_view') and self.qa_markdown_view:
                # 마크다운 모드 - 전체 히스토리 다시 렌더링
                self.render_qa_history()
            else:
                # 텍스트 모드
                # 현재 텍스트 업데이트
                plain_text = ""
                for item in self.qa_history_list:
                    if item["type"] == "question":
                        plain_text += f"질문: {item['content']}\n\n"
                    elif item["type"] == "answer":
                        plain_text += f"답변: {item['content']}\n\n"
                    elif item["type"] == "error":
                        plain_text += f"오류: {item['content']}\n\n"
                
                # 텍스트 업데이트
                self.qa_history.setPlainText(plain_text)
            
            # UI 다시 활성화
            self.question_input.setEnabled(True)
            self.submit_question_button.setEnabled(True)
            self.submit_question_button.setText("질문하기")
            self.statusBar.showMessage("답변이 준비되었습니다.")
            
            # 히스토리 스크롤을 맨 아래로 이동
            self.qa_history.verticalScrollBar().setValue(
                self.qa_history.verticalScrollBar().maximum()
            )
        except Exception as e:
            # 오류 처리
            self.show_qa_error(f"답변 표시 중 오류가 발생했습니다: {str(e)}")

    def restore_qa_history(self):
        """저장된 질문-답변 히스토리 복원"""
        if not self.qa_history_list:
            return
            
        # 기존 히스토리 초기화
        self.qa_history.clear()
        
        # 저장된 히스토리 순차적으로 추가
        for item in self.qa_history_list:
            if item.get("markdown", False) and item["type"] == "answer":
                # 마크다운 변환된 답변
                self.qa_history.append(item["html"])
            else:
                # 일반 질문 및 오류
                self.qa_history.append(item["html"])
        
        # 스크롤을 맨 아래로 이동
        self.qa_history.verticalScrollBar().setValue(
            self.qa_history.verticalScrollBar().maximum()
        )

    def update_streaming_briefing(self, text_chunk):
        """브리핑 스트리밍 실시간 업데이트"""
        # 스트리밍 출력을 위해 텍스트 누적
        self.streaming_briefing_text += text_chunk
        
        # 마크다운 렌더링
        if self.is_briefing_streaming:
            if self.markdown_view:
                # 마크다운을 HTML로 변환하여 표시
                try:
                    html_content = markdown.markdown(
                        self.streaming_briefing_text, 
                        extensions=['tables', 'fenced_code', 'codehilite']
                    )
                    
                    # 현재 폰트 이름 가져오기
                    font = self.briefing_text.font()
                    font_name = font.family()
                    
                    # CSS 적용
                    css = self.markdown_css.replace('"{}"', f'"{font_name}"')
                    
                    # HTML 설정
                    self.briefing_text.setHtml(css + html_content)
                except Exception as e:
                    # 마크다운 변환 오류 시 일반 텍스트로 표시
                    self.briefing_text.setPlainText(self.streaming_briefing_text)
            else:
                # 텍스트 모드일 경우 일반 텍스트로 표시
                self.briefing_text.setPlainText(self.streaming_briefing_text)
            
            # 스크롤을 항상 최하단으로 유지
            self.briefing_text.verticalScrollBar().setValue(
                self.briefing_text.verticalScrollBar().maximum()
            )

    def toggle_qa_view(self):
        """질문-답변 영역의 마크다운 뷰와 일반 텍스트 뷰 전환"""
        if hasattr(self, 'qa_markdown_view'):
            # 텍스트 → 마크다운 전환 또는 그 반대
            self.qa_markdown_view = not self.qa_markdown_view
            
            if self.qa_markdown_view:
                # 텍스트 → 마크다운 전환
                self.qa_toggle_view_button.setText("🔄 텍스트 보기")
                # 질문/답변 기록을 HTML로 렌더링
                self.render_qa_history()
            else:
                # 마크다운 → 텍스트 전환
                self.qa_toggle_view_button.setText("🔄 마크다운 보기")
                # 질문/답변 기록을 일반 텍스트로 표시
                plain_text = ""
                for item in self.qa_history_list:
                    if item["type"] == "question":
                        plain_text += f"질문: {item['content']}\n\n"
                    elif item["type"] == "answer":
                        plain_text += f"답변: {item['content']}\n\n"
                    elif item["type"] == "error":
                        plain_text += f"오류: {item['content']}\n\n"
                
                self.qa_history.setPlainText(plain_text)
        else:
            # 초기화
            self.qa_markdown_view = True
            self.qa_toggle_view_button.setText("🔄 텍스트 보기")
            self.render_qa_history()
    
    def render_qa_history(self):
        """질문-답변 히스토리를 마크다운/HTML로 렌더링"""
        html_content = """
        <html>
        <head>
        <style>
            body {
                font-family: sans-serif;
                line-height: 1.4;
                color: #2c3e50;
                margin: 0;
                padding: 0;
            }
            .question, .answer, .error, .streaming {
                margin-bottom: 12px;
                padding: 10px;
                border-radius: 5px;
            }
            .question {
                background-color: #f1f8ff;
                border-left: 4px solid #3498db;
            }
            .answer {
                background-color: #f9f9f9;
                border-left: 4px solid #2ecc71;
            }
            .streaming {
                background-color: #f9f9f9;
                border-left: 4px solid #f39c12;
            }
            .error {
                background-color: #fff0f0;
                border-left: 4px solid #e74c3c;
            }
            .result-image {
                max-width: 100%;
                border: 1px solid #ddd;
                border-radius: 5px;
                margin: 10px 0;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            h1, h2, h3, h4, h5, h6 {
                margin-top: 16px;
                margin-bottom: 12px;
            }
            p {
                margin-top: 6px;
                margin-bottom: 12px;
            }
            ul, ol {
                margin-top: 6px;
                margin-bottom: 12px;
                padding-left: 2em;
            }
            li {
                margin-bottom: 0.2em;
            }
            pre {
                background-color: #f7f7f7;
                padding: 10px;
                border-radius: 3px;
                overflow-x: auto;
                margin: 10px 0;
            }
            code {
                font-family: monospace;
                background-color: #f0f0f0;
                padding: 2px 4px;
                border-radius: 3px;
            }
        </style>
        </head>
        <body>
        """
        
        for item in self.qa_history_list:
            if item["type"] == "question":
                # 질문 HTML 생성
                html_content += f"""<div class="question"><strong>질문 ({item["timestamp"]}):</strong><br>{item["content"]}</div>"""
            elif item["type"] == "answer":
                # 마크다운 변환
                try:
                    answer_html = markdown.markdown(
                        item["content"],
                        extensions=['tables', 'fenced_code', 'codehilite', 'nl2br', 'sane_lists']
                    )
                    html_content += f"""<div class="answer"><strong>답변 ({item["timestamp"]}):</strong><br>{answer_html}</div>"""
                    
                    # 결과 이미지가 있으면 표시
                    if "result_image" in item and item["result_image"]:
                        html_content += f"""<div class="answer"><strong>실행 결과:</strong><br><img src="{item["result_image"]}" class="result-image" alt="실행 결과"></div>"""
                except Exception as e:
                    # 변환 실패 시 일반 텍스트로 처리
                    formatted_text = item["content"].replace("\n", "<br>")
                    html_content += f"""<div class="answer"><strong>답변 ({item["timestamp"]}):</strong><br>{formatted_text}</div>"""
            elif item["type"] == "streaming":
                # 스트리밍 중인 답변
                try:
                    streaming_html = markdown.markdown(
                        item["content"],
                        extensions=['tables', 'fenced_code', 'codehilite', 'nl2br', 'sane_lists']
                    )
                    html_content += f"""<div class="streaming"><strong>답변 중...</strong><br>{streaming_html}</div>"""
                except Exception as e:
                    # 변환 실패 시 일반 텍스트로 처리
                    formatted_text = item["content"].replace("\n", "<br>")
                    html_content += f"""<div class="streaming"><strong>답변 중...</strong><br>{formatted_text}</div>"""
            elif item["type"] == "error":
                # 오류 메시지
                html_content += f"""<div class="error"><strong>⚠️ 오류:</strong> {item["content"]}</div>"""
        
        html_content += """
        </body>
        </html>
        """
        
        # HTML 설정
        self.qa_history.setHtml(html_content)

    def handle_generated_code(self, code):
        """생성된 Python 코드 처리 및 실행"""
        self.statusBar.showMessage("생성된 코드를 실행하는 중...")
        
        # CodeExecutionThread 인스턴스 생성 및 실행
        self.code_exec_thread = CodeExecutionThread(code)
        self.code_exec_thread.execution_completed.connect(self.handle_code_execution_result)
        self.code_exec_thread.start()

    def handle_code_execution_result(self, success, message, result_file):
        """코드 실행 결과 처리"""
        # 마지막 질문-답변 항목에 실행 결과 추가
        for i in range(len(self.qa_history_list) - 1, -1, -1):
            if self.qa_history_list[i]["type"] == "answer":
                # 이미지 파일 결과가 있는 경우
                if success and result_file:
                    # 결과 파일 경로를 절대 경로로 변환
                    abs_result_file = os.path.abspath(result_file)
                    self.qa_history_list[i]["result_image"] = abs_result_file
                    
                    # 확장자에 따른 처리
                    file_ext = os.path.splitext(result_file)[1].lower()
                    if file_ext == '.html':
                        # HTML 파일인 경우 새 창으로 열기
                        self.qa_history_list[i]["content"] += f"\n\n**HTML 시각화 생성됨:** 파일 열기 [{os.path.basename(result_file)}]({abs_result_file})"
                        
                        # 웹브라우저로 결과 파일 열기
                        try:
                            webbrowser.open(f"file://{abs_result_file}")
                        except Exception as e:
                            print(f"HTML 파일 열기 오류: {str(e)}")
                    
                    self.statusBar.showMessage(f"코드 실행 완료: {os.path.basename(result_file)}")
                else:
                    error_msg = message.replace("\n", "<br>")
                    self.qa_history_list[i]["content"] += f"\n\n**코드 실행 결과:** {message}"
                    self.statusBar.showMessage(f"코드 실행 결과: {message[:50]}...")
                
                # 히스토리 다시 렌더링
                self.render_qa_history()
                break

class ChatGPTBriefingThread(QThread):
    """
    ChatGPT API를 사용하여 브리핑 생성을 위한 백그라운드 스레드
    """
    update_signal = pyqtSignal(str)
    finished_signal = pyqtSignal(str)
    error_signal = pyqtSignal(str)
    progress_signal = pyqtSignal(int)
    stream_signal = pyqtSignal(str)  # 스트리밍 출력을 위한 시그널 추가

    def __init__(self, layout_file, tmp_briefing_file, model_path, api_key, gpt_model="gpt-4o-2024-11-20", language="korean"):
        QThread.__init__(self)
        self.layout_file = layout_file
        self.tmp_briefing_file = tmp_briefing_file
        self.model_path = model_path  # 호환성을 위해 유지 (사용되지 않음)
        self.api_key = api_key  # ChatGPT API 키
        self.gpt_model = gpt_model  # ChatGPT 모델
        self.language = language
        self.update_interval = 50  # 업데이트 간격 (ms)
        self.is_generating = False  # 생성 진행 중 플래그
        self.progress_timer = None  # 진행 타이머
        self.current_progress = 0   # 현재 진행률

    def run(self):
        """
        QA 스레드 실행 - 레이아웃 및 브리핑 내용을 바탕으로 질문-답변 생성
        
        특별 키워드 "IIFA" 사용법:
        - 메시지 시작 또는 끝에 "IIFA"를 추가하면 시각화/코드 생성 모드 활성화
        - 그 외의 경우에는 일반 전술 조언 모드로 작동
        - 키워드는 대소문자를 구분하지 않음 (iifa, IIFA 모두 인식)
        """
        try:
            # 초기화 단계 - 진행률 5%
            self.current_progress = 5
            self.progress_signal.emit(self.current_progress)
            self.update_signal.emit("레이아웃 로드 중...")
            
            # 진행 상태 업데이트 타이머 시작
            self.start_progress_timer()
            
            # 레이아웃 로드 - 진행률 20%
            layout = load_layout_from_file(self.layout_file)
            self.current_progress = 20
            self.progress_signal.emit(self.current_progress)
            
            # 레이아웃 분석 - 진행률 30%
            self.update_signal.emit("공간 레이아웃 분석 중...")
            analysis = analyze_layout(layout)
            self.current_progress = 30
            self.progress_signal.emit(self.current_progress)
            
            # 브리핑 생성 시작 - 진행률 40%부터 95%까지 서서히 증가
            self.update_signal.emit("ChatGPT로 브리핑 생성 중...")
            self.current_progress = 40
            self.progress_signal.emit(self.current_progress)
            
            # 브리핑 생성 시작을 플래그로 표시
            self.is_generating = True
            
            # ChatGPT API 호출용 프롬프트 생성
            layout_str = layout.to_language_string()
            
            # API 요청 헤더 및 URL 설정
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.api_key}"
            }
            api_url = "https://api.openai.com/v1/chat/completions"
            
            # 언어 설정
            lang_instruction = ""
            if self.language == "korean":
                lang_instruction = "\n\n중요: 당신의 응답은 반드시 한국어로 작성해야 합니다. 모든 제목, 용어, 내용을 한국어로 작성하세요."
            
            # 간결한 프롬프트 생성
            system_prompt = f"""당신은 3D 공간 정보를 분석하고 요약하는 전문가이자 군사 작전 전문가입니다. 제공된 공간 레이아웃 정보를 바탕으로 정확하고 데이터에 기반한 전술적 브리핑과 작전 관련 정보를 생성해야 합니다. 

작전을 수행하는 현장 요원과 지휘관에게 전장 상황을 사전에 파악하고 효과적인 작전 계획을 수립하는 데 필수적인 정보를 제공해야 합니다. 특히 다음에 중점을 두세요:
1. 인간이 일반적으로 파악하기 어렵거나 간과하기 쉬운 전술적 요소
2. 작전 수행에 핵심적인 영향을 미치는 중요 정보
3. 위험 요소와 기회 요소를 명확히 식별하는 데이터 기반 분석
4. 현장 상황에서 빠르게 참조할 수 있는 정량적 데이터와 명확한 분석
5. 시각적 제한사항(사각지대, 맹점)과 음향 특성이 작전에 미치는 영향
6. 공간 구조가 통신 및 장비 효율성에 미치는 영향
7. 공간 내 이동 패턴 예측 및 통제 지점 식별
8. 치명적 경로 및 위험 구역 식별과 우회 방법


항상 마크다운 형식을 사용하여 정보를 구조화하세요. 가능한 한 정확한 수치 데이터와 공간적 특성을 포함하고, 실제 작전에 활용할 수 있는 통신, 전술, 장비 관련 정보도 포함하세요. 임의로 답변을 중단하지 마세요. 반드시 모든 항목에 대한 완전한 정보를 제공해야합니다."""
            
            # 사용자 프롬프트 생성 (확장된 버전)
            user_prompt = f"""다음은 3D 공간의 상세 레이아웃 정보입니다:

{layout_str}

이 공간에 대한 상세한 전술적 브리핑과 작전 계획을 작성해주세요. 다음 핵심 섹션을 포함하되, 정량적 수치와 공간 특성에 집중해주세요:

## 1. 개요
- 공간 유형, 정확한 치수(가로, 세로, 높이), 면적 및 체적 수치
- 공간 배치의 특징적 패턴 및 중요 구조적 특성
- 가장 중요한 전술적 특성 5가지와 그 중요도 점수(1-10)
- 작전 성공에 결정적 영향을 미치는 핵심 요소 3가지
- 즉각적인 조치가 필요한 위험 요소 및 기회 요소

## 2. 공간 구조 분석
- 모든 벽체의 정확한 위치, 치수, 재질 추정
- 모든 출입구와 창문의 위치, 크기, 개폐 방향 분석
- 구조적 특이점과 취약점 상세 평가(수치 데이터 포함)
- 천장 및 바닥 구조의 특성과 전술적 영향
- 구조물 붕괴 가능성 및 화재 확산 경로 분석
- 안정성이 의심되는 요소 및 대응 방안

## 3. 접근점 종합 분석
- 모든 출입구의 상세 목록과 접근 난이도(1-10)
- 각 접근점의 치수, 재질, 구조적 특성
- 주요 접근 경로의 위험 요소와 방어/공격 가능성 분석
- 출입구 간 상관관계 및 시선/이동 연결성 매트릭스
- 접근점별 최적 돌파 방법 및 필요 장비
- 각 출입구의 음향 특성(소리 전달 계수)
- 외부 연결 창문/문에 대한 대저격수 고려사항

## 4. 이동 및 시야 분석
- 주요 이동 경로의 정확한 길이, 폭, 높이
- 모든 구역 간 최단 경로와 소요 시간 예측(초 단위)
- 시야 분석: 각 주요 지점에서의 가시 범위와 각도(도 단위)
- 맹점, 사각지대, 병목지점의 정확한 위치와 크기
- 공간 내 이동 패턴 예측 및 통제 지점 식별
- 치명적 경로 및 위험 구역 식별과 우회 방법
- 소리 전파 특성과 감지 확률 분석
- 방 청소 순서 및 팀 배치 권장사항
- 이동 템포 분석(공간 제약에 따른 속도 변화 권장)
- 진입 옵션(강제/비강제)과 성공 확률

## 5. 물체 및 장애물 분석
- 모든 주요 물체의 정확한 위치, 치수, 재질 추정
- 장애물 특성에 따른 방어 등급 평가(1-10)
- 엄폐물의 효과적인 방어 범위와 시간(탄종별 관통 저항 포함)
- 물체 배치 패턴과 공간 활용 효율성 분석
- 각 물체의 탄도학적 보호 등급(레벨 I-IV 상당)
- 다양한 각도에서의 은폐 옵션과 감지 확률
- 각 엄폐물 위치에서의 360° 화력 분석
- 물체의 안정성 분석(파괴 시 2차 위험 요소)

## 6. 전술적 위치 평가
- 최적의 방어/공격 위치 좌표와 각 위치의 강점/약점
- 각 위치에서의 통제 가능 영역 비율과 사각지대
- 위험도 히트맵(공간의 각 구역별 노출 수준 수치화)
- 우선순위가 높은 통제 지점의 정확한 좌표와 중요도
- 각 적 위치에 대한 대응 위치 분석
- 가장 가능성 높은 및 가장 위험한 적 행동 과정 평가
- 정확한 위치 좌표와 팀 구성을 포함한 상세 병력 배치
- 최대 지원 가능 인원과 한계 분석
- 특수 무기 위치 권장사항(지정 사수, 조준사격 등)

## 7. 환경 및 자원 분석 [매우 상세하게 작성]
- 조명 조건 분석 및 명암 대비 지점 식별(주/야간 차이 포함)
- 음향 특성 평가(소리 전파 패턴, 울림, 차폐)
- 최적 장비 배치 좌표와 인원 배치 제안(정확한 인원수 및 위치)
- 공간 특성에 따른 특수 장비 요구사항 및 효과 예측
- 온도, 습도, 환기 등 환경 조건이 작전에 미치는 영향
- 자연광/인공조명 특성과 작전 시간대별 시야 조건 변화
- 바닥 재질과 소음 발생 관계 분석
- 감지될 수 있는 공간 내 다양한 감각 정보(냄새, 진동 등)

## 8. 통신 체계 계획 
- 공간 내 무선 통신 효율성 및 차폐 구역 분석
- 최적의 통신 중계 위치 및 통신 장비 설정 제안
- 통신 두절 구역 및 비상 통신 프로토콜
- 신호 간섭 및 방해 가능성 평가(1-10)
- 각 위치별 통신 품질 등급 지정(1-10)
- 물리적 방해물에 의한 통신 장애 예상 지점
- 주파수 및 통신 방식 권장사항(특정 통신 장비 추천)
- 장비별 신호 감쇠 수준과 최대 작동 거리 계산
- 신호 보안 및 도청 위험성 평가

## 9. 작전 전술 및 절차 
- 공간별 권장 작전 전술 및 기동 방식
- 팀 구성 및 역할 분담 제안(인원별 임무와 위치)
- 단계별 작전 수행 타임라인 및 조정점
- 예상 시나리오별 대응 계획 및 우발상황 대비책
- 작전 성공률 및 위험도 계산(정량적 수치)
- 시간대별 작전 수행 조건 및 대응 방안
- 특수 상황(인질, 민간인, 폭발물 등) 대응 프로토콜
- 병력 분산과 집중에 관한 전술 제안
- 정밀한 시간-이동 모델 기반의 작전 템포 분석
- 상황별 우선순위와 결정 지점 명시

## 10. 장비 및 무기 추천 
- 공간 특성에 최적화된 무기 및 장비 세트
- 주요 위치별 권장 화기 유형 및 탄약 종류
- 특수 장비 필요성 및 효과 분석(열화상, 야간 투시, 방탄 등)
- 장비별 효율성 평가 및 우선순위(1-10)
- 유효 사거리와 공간 치수 기반 무기 선택 근거
- 필수 방호 장비 및 장비별 이동성-보호 균형점
- 구체적인 화기 모델 및 접근법별 추천 부착물
- 특수 상황별 필요 장비 및 효율성 평가
- 장비 중량과 이동성 간의 상관관계 분석

## 11. 종합 전술 평가 [가장 상세하게 작성]
- 전체 공간의 방어 난이도 및 공격 용이성 점수(1-10)
- 주요 전술적 장단점의 정량적 평가
- 공간 활용을 위한 최적화 제안과 예상 효과
- 특이사항 및 특별 고려사항(정량적 데이터 기반)
- 작전 수행 시 고려해야 할 가장 중요한 요소 5가지
- 각 접근법별 성공 확률과 위험도 상세 분석
- 공간별 전술 우선순위와 자원 배분 권장사항
- 최적의 작전 수행 방식에 대한 종합적 제안
- 시뮬레이션 기반 최적 작전 경로와 타임라인
- 인명 위험을 최소화하는 이동 및 작전 패턴 제안

모든 섹션은 동일한 수준의 상세도로 작성해주세요. 특히 후반부 섹션(6-11)은 앞부분과 동일하거나 더 높은 수준의 상세함과 구체적인 정보를 포함해야 합니다. 각 섹션에는 다음을 포함하세요:
- 일반적인 설명보다는 정량적 데이터와 구체적 수치 중심의 분석
- 공간별, 상황별 차별화된 전술적 접근법
- 인공지능 관점에서 발견한 일반 사람이 놓치기 쉬운 공간적 특성과 그 의미
- 유사한 작전 환경에서의 과거 경험과 교훈에 기반한 실용적 조언
- 각 요소의 중요도와 영향력에 대한 명확한 평가(1-10 척도)

항상 마크다운 형식을 사용하여 정보를 구조화하고, 각 섹션마다 핵심 인사이트와 전문가 코멘트를 추가하세요. 특히 핵심 결정 사항과 생명을 위협할 수 있는 요소들을 강조 표시하여 신속한 참조가 가능하도록 하세요.

"""
            
            # 메시지 구성
            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
            
            # API 요청 본문 구성 - 스트리밍 모드 활성화
            request_body = {
                "model": self.gpt_model,
                "messages": messages,
                "temperature": 0.5,  # 더 일관된 결과를 위해 낮은 temperature
                "max_tokens": 15000,   # 매우 상세한 브리핑을 위해 토큰 수 증가
                "top_p": 0.95,
                "frequency_penalty": 0,
                "presence_penalty": 0.1,  # 약간의 다양성 추가
                "stream": True  # 스트리밍 모드 활성화
            }
            
            # 전체 응답을 저장할 변수
            full_response = ""
            self.update_signal.emit("브리핑 생성 중...")
            
            # API 요청 전송 (스트리밍)
            with requests.post(
                api_url,
                headers=headers,
                json=request_body,
                timeout=300,  # 타임아웃 300초
                stream=True  # 스트리밍 모드
            ) as response:
                
                if response.status_code == 200:
                    for line in response.iter_lines():
                        if line:
                            line_text = line.decode('utf-8')
                            
                            # "data: " 접두사 처리
                            if line_text.startswith("data: "):
                                line_text = line_text[6:]  # "data: " 제거
                            
                            # 스트리밍 종료 메시지 확인
                            if line_text == "[DONE]":
                                break
                                
                            try:
                                # JSON 파싱
                                json_data = json.loads(line_text)
                                
                                # 델타 텍스트 추출
                                if "choices" in json_data and json_data["choices"]:
                                    delta = json_data["choices"][0].get("delta", {})
                                    
                                    if "content" in delta:
                                        content = delta["content"]
                                        full_response += content
                                        # 실시간으로 스트리밍 시그널 발생
                                        self.stream_signal.emit(content)
                                        # 생성 내용 일부 표시
                                        if len(content.strip()) > 0 and len(full_response) % 50 == 0:
                                            self.update_signal.emit(f"브리핑 생성 중... {len(full_response)} 글자 생성됨")
                            except json.JSONDecodeError:
                                # JSON 디코딩 오류는 무시
                                continue
                    
                    # 응답이 비어있거나 오류가 발생한 경우 폴백 브리핑 생성
                    if not full_response.strip():
                        self.update_signal.emit("ChatGPT 응답이 비어있어 기본 브리핑 생성 중...")
                        full_response = generate_tactical_fallback_briefing(analysis, self.language)
                    
                    # 생성 완료 표시
                    self.is_generating = False
                    self.current_progress = 95
                    self.progress_signal.emit(self.current_progress)
                    
                    # 결과 저장
                    with open(self.tmp_briefing_file, "w", encoding="utf-8") as f:
                        f.write(full_response)
                    
                    # 진행률 타이머 중지
                    self.stop_progress_timer()
                    
                    # 완료 신호 발생
                    self.current_progress = 100
                    self.progress_signal.emit(self.current_progress)
                    self.finished_signal.emit(full_response)
                else:
                    error_msg = f"ChatGPT API 오류 (코드 {response.status_code}): {response.text}"
                    self.error_signal.emit(error_msg)
                    # API 오류 시 폴백 브리핑 생성
                    fallback_briefing = generate_tactical_fallback_briefing(analysis, self.language)
                    self.finished_signal.emit(fallback_briefing)
            
        except Exception as e:
            # 오류 발생 시 타이머 중지
            self.stop_progress_timer()
            
            self.error_signal.emit(f"브리핑 생성 오류: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def start_progress_timer(self):
        """진행 상태 업데이트 타이머 시작"""
        self.progress_timer = QTimer()
        self.progress_timer.timeout.connect(self.update_progress_gradually)
        self.progress_timer.start(300)  # 300ms 간격으로 업데이트
    
    def stop_progress_timer(self):
        """진행 상태 업데이트 타이머 중지"""
        if self.progress_timer and self.progress_timer.isActive():
            self.progress_timer.stop()
    
    def update_progress_gradually(self):
        """브리핑 생성 중에 진행률을 서서히 증가시킴"""
        if self.is_generating and self.current_progress < 95:
            # 40% ~ 95% 사이에서 서서히 증가
            increment = max(0.2, min(0.5, (95 - self.current_progress) / 90))
            self.current_progress = min(95, self.current_progress + increment)
            self.progress_signal.emit(int(self.current_progress))

def main():
    """메인 함수"""
    parser = argparse.ArgumentParser(description="RRD Viewer with Briefing Popup - Modern UI")
    parser.add_argument("-i", "--input", type=str, help="입력 RRD 파일 경로 (이전 버전 호환용)")
    parser.add_argument("-r", "--rrd", type=str, help="입력 RRD 파일 경로")
    parser.add_argument("-l", "--layout", type=str, help="레이아웃 파일 경로 (.txt)")
    parser.add_argument("-b", "--briefing", type=str, help="브리핑 파일 경로 (.txt)")
    parser.add_argument("-m", "--model", type=str, default="manycore-research/SpatialLM-Llama-1B", 
                        help="SpatialLM 모델 경로")
    parser.add_argument("-g", "--language", type=str, default="korean", choices=["english", "korean"],
                        help="브리핑 언어 (english/korean)")
    
    args = parser.parse_args()
    
    # -i 또는 -r 중 하나는 반드시 필요
    rrd_file = args.rrd if args.rrd else args.input
    if not rrd_file:
        print("오류: RRD 파일 경로가 필요합니다. -r 또는 -i 옵션을 사용하세요.")
        parser.print_help()
        sys.exit(1)
    
    # 입력 파일 확인
    if not os.path.exists(rrd_file):
        print(f"오류: 입력 파일 '{rrd_file}'을 찾을 수 없습니다.")
        sys.exit(1)
    
    # RRD 파일 확인 - 확장자가 없어도 괜찮음
    if not rrd_file.lower().endswith('.rrd'):
        print(f"경고: 파일 '{rrd_file}'은 .rrd 확장자가 아닙니다. 계속 진행합니다.")
    
    # QApplication 생성
    app = QApplication(sys.argv)
    
    # 기본 스타일 설정
    app.setStyle('Fusion')
    
    # 브리핑 뷰어 생성
    viewer = BriefingViewer(
        rrd_file=rrd_file, 
        model_path=args.model, 
        language=args.language,
        layout_file=args.layout,
        briefing_file=args.briefing
    )
    
    # 애플리케이션 실행
    sys.exit(app.exec_())

if __name__ == "__main__":
    main() 

